general details:
everything is in base 10
memory indexed from 00-99
numbers are 000000-999999
every word is 6 decimal digits
program is placed in memory starting at position 00
arguments are in order, right after opcode
e.g. mov AX, 99    is    030199

registers:
AX, BX : general purpose. coding: 01 for AX and 02 for BX, initialized to 000000 for convenience
FR : flag register, for internal use in cmp and je commands, not really a register
                    it is just a component, inline - not a register
IP : instruction pointer, we'll allow this to be addressed as 99
IR : instruction register, stores the current instruction, not really implemented

opcode: instruction (explanation, optional)
-------------------------------------------
00: ret (simply ends program)
01: mov register, constant
02: mov register, register
03: mov register, memory
04: mov memory, constant
05: mov memory, register

06: add register, constant
07: add register, register

08: cmp register, constant
09: cmp register, register

10: jmp constant
11: jmp register
12: je constant
13: je register



// notes, i've added many repetative instructions because they make coding simpler, and since there are only 100 words of memory, being a CISC is better, so this is closer to a CISC, with many slightly redundant instructions, all have had a lot of thought put into them though, so please refer questions to me if i forgot to document some decisions here.

my additions:
14: mov registerA, PTR [registerB] (registerA = mem[registerB])
15: mov PTR [registerA], registerB (mem[registerA] = registerB)
16: sub register, register
17: sub register, constant (can't be replaced by addition with 10's complement because that would require signed vs unsigned stuff regarding sign extension which is hard in base 10, this is better)
18: sub constant, register (seperate because order matters in subtraction, still saves to register)
19: cmp constant, register (same reason, matters for jl)
20: jne constant (if not equal, then IP = constant)
21: jne register (if not equal, then IP = register)
22: jl constant (if less than, then IP = constant)
23: jl register (if less than, then IP = register)

(these are included because it shortens a few instructions down into one, worth it when there are only 100 words of memory... e.g. when doing binary search, reduces cmp operations needed)
24: jg constant (if greater than, then IP = constant)
25: jg register (if greater than, then IP = register)

26: syscall code  // handled as such, AX is the operand
index of syscall codes:
    0: send char to host (computer that's connected) (AX is address to send)
    1: wait to receive a char from host (computer that's connected) (AX is address to save in)
    2: send null terminated string to host (AX is the address to send)
    3: receive null-terminated char string from host (AX is address to write to) 
    4: send word to host (AX is address to send)
    5: send null terminated string of whole words to host (AX is the address to send)
    6: receive null-terminated string of whole words from host (AX is address to write to)
    7: check if there's a word waiting to be received (AX is address to write result to)
 

allow IP access through register 99, adds complexity but very useful, replaces jump register
    and also allows calculations on IP, for specialized jumping