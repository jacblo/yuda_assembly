; edit distance for two words up to 5 letters (no more memory after that...)
; get first string
mov ax, 51 ; first position
syscall 3 ; receive string from host
mov [56], 0 ; null terminate it if it's more than 5 chars

; get second string
mov ax, 57
syscall 3 ; recv string
mov [62], 0 ; null terminate if too long

; A is (5+1)x(5+1) array, starting at 63

; initialize A with values on first row and column
; starting at i=1 because A[0,0]=0 already
mov AX, 64 ; ptr to A[1,0]
mov BX, 1 ; i
loop1:
    ; A[i, 0] = i
    mov PTR [AX], BX

    ; i++
    add BX, 1
    add AX, 1
    cmp BX, 6 ; so we run 5 times
    jne loop1
add AX, 1

; starting at j=1 because A[0,0]=0 already
mov AX, 69 ; ptr to A[0,1]
mov BX, 1 ; j
loop2:
    ; A[0, j] = j
    mov PTR [AX], BX

    ; i++
    add BX, 1
    add AX, 6 ; so we go down a row
    cmp BX, 6 ; so we run 5 times
    jne loop2
add AX, 1

loop3:
    ; check left
    mov AX, [current_address]
    sub AX, 1 ; AX points at left
    mov BX, PTR [AX]
    mov AX, [min]
    cmp BX, AX
    jg greater1 ; not less than min
    mov [min], BX ; update minimum
    greater1:

    ; check up
    mov AX, [current_address]
    sub AX, 6 ; AX points at up
    mov BX, PTR [AX]
    mov AX, [min]
    cmp BX, AX
    jg greater2 ; not less than min
    mov [min], BX ; update minimum
    greater2:

    ; check up left
    mov AX, [current_address]
    sub AX, 7 ; AX points at up left
    mov BX, PTR [AX]
    mov AX, [min]
    cmp BX, AX
    jg greater3 ; not less than min
    mov [min], BX ; update minimum
    greater3:

    ; calculate current
    mov BX, [min]
    add BX, 1
    mov AX, [current_address]
    mov PTR [AX], BX ; update current
    
    mov [min], 99 ; prep for next time
    
    ; go to next
    add AX, 1
    mov BX, PTR [AX]
    ; if it's already set, and isn't 0 we incrememt again because
    ; we just went down a line
    cmp BX, 0
    je didnt_row_down ; if it's 0 then we didn't go down a line
    add AX, 1 ; if we went down a row we move once more
    didnt_row_down:

    cmp AX, 99 ; if we got to the end
    jne loop3 ; if we didn't we loop

ret

current_address:70 ; first internal location A[1,1]
min: 99 ; min value for current number, starts at highest number