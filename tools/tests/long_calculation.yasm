; assumes legal input that's up to 5 chars
; too tight to fit program that does more than that

mov [current_address], first_address ; set it up

loop3:
    ; find minimum of three surrounding loop
    loop4:
        ; find value to subtract
        mov BX, [sub_addr]

        ; check left
        mov AX, [current_address]
        sub AX, BX ; AX points at left
        
        ; update the value to subtract
        add BX, 1 ; increment to second
        mov [sub_addr], BX

        mov BX, PTR [AX]
        mov AX, [min]
        cmp BX, AX
        jg greater1 ; not less than min
        mov [min], BX ; update minimum
        greater1:

        ; check next
        mov BX, [sub_addr]
        cmp BX, sub_addr
        jne loop4

    ; calculate current
    mov BX, [min]
    add BX, 1
    mov AX, [current_address]
    mov PTR [AX], BX ; update current
    
    mov [min], 99 ; prep for next time
    
    ; go to next
    add AX, 1
    mov BX, PTR [AX]
    ; if it's already set, and isn't 0 we incrememt again because
    ; we just went down a line
    cmp BX, 0
    je didnt_row_down ; if it's 0 then we didn't go down a line
    add AX, 1 ; if we went down a row we move once more
    didnt_row_down:

    cmp AX, 99 ; if we got to the end
    jne loop3 ; if we didn't we loop


; print result
mov AX, final_pos
syscall 4 ; print number
ret

current_address:0
min: 99 ; min value for current number, starts at highest number

subtractions:   ; the three values to subtract from every position to get up
                ; keft and up left
1
6
7
sub_addr: subtractions

word1:
0
0
0
0
0
word2:
0
0
0
0
0
matrix:
0
1
2
3
4
5
first_address:
1
0
0
0
0
0
2
0
0
0
0
0
3
0
0
0
0
0
4
0
0
0
0
0
5
0
0
0
0
final_pos:
0